# Copyright (c) Microsoft. All rights reserved.

from datetime import datetime, timedelta, timezone
from typing import Generic, TypeVar
from uuid import uuid4

T = TypeVar("T")


class MessageEnvelope(Generic[T]):
    """Transport-level wrapper.

    Can carry observability/retry metadata around any domain
    payload (ConcurrentRequestMessage, GroupChatMessage, ...)

    Actors stay focused on business logic objects (ConcurrentRequestMessage, etc.);
    the runtime only sees envelopes, so changing transports (in process or a distributed runtime)
    or injecting middleware (tracing, guardrails) requires zero changes to orchestration code.
    """

    def __init__(
        self,
        payload: T,
        *,
        correlation_id: str | None = None,
        causation_id: str | None = None,
        ttl_ms: int | None = None,
        headers: dict[str, str] | None = None,
    ) -> None:
        """Initialize a MessageEnvelope.

        Args:
            id: Unique identifier for *this* envelope instance, autogenerated.
            correlation_id: Identifier shared by all envelopes in the same orchestration run.
            causation_id: `id` of the parent envelope that directly caused this one.
            timestamp: UTC moment the envelope was created.
            ttl_ms: TTL (milliseconds) before the envelope is discarded.
            retry_count: Delivery attempts so far; runtime increments on redelivery.
            headers: Transport metadata (priority, guardrail tags, etc.).
            payload: The actual domain message (e.g., `ConcurrentRequestMessage`).
        """
        self.id: str = uuid4().hex
        self.correlation_id: str = correlation_id or self.id
        self.causation_id: str | None = causation_id
        self.timestamp: datetime = datetime.now(tz=timezone.utc)
        self.ttl_ms: int | None = ttl_ms
        self.retry_count: int = 0
        self.headers: dict[str, str] = headers or {}
        self.payload: T = payload

    def is_expired(self, *, now: datetime | None = None) -> bool:
        """Check if the message is expired."""
        if self.ttl_ms is None:
            return False
        now = now or datetime.now(tz=timezone.utc)
        return now > self.timestamp + timedelta(milliseconds=self.ttl_ms)

    def __repr__(self) -> str:
        """Return a string representation of the MessageEnvelope."""
        return (
            f"MessageEnvelope(id={self.id!s}, corr={self.correlation_id!s}, "
            f"payload={self.payload!r}, retry={self.retry_count})"
        )
