### Comparative Table: Function Calling in Python LLM Orchestration Frameworks

| Framework      | Tool/Function Registration | Receives `self`/Stateful? | Tool Description & Schema | Invocation/Execution Mechanism | Namespacing/Discovery | Advanced Orchestration (Multi-agent, Hierarchy) | Unique Features/Notes |
|:-------------- |:--------------------------|:-------------------------|:-------------------------|:-------------------------------|:---------------------|:-----------------------------------------------|:---------------------|
| **Semantic Kernel** | Decorators (`@kernel_function`) on **class methods**; plugins are Python classes registered to the kernel (`kernel.add_plugin` or `import_plugin_from_object`). | Yes (methods receive `self`, supporting per-plugin instance state). | Description and schema via decorator and Python type annotations; introspected at registration. | Kernel advertises available plugins/functions to LLM (auto/manual modes). Model issues a function call (JSON); kernel looks up and invokes Python method. | Namespacing by plugin (class) name and function name; plugin library is central registry. | Kernel can filter/expose by plugin; can support different function choice strategies; per-plugin isolation by kernel instance. | Native support for stateful plugins and per-instance state; flexible function exposure via `FunctionChoiceBehavior`. |
| **OpenAI Agent SDK** | Decorate standalone Python functions with `@function_tool`; pass the resulting tool object(s) to agent's `tools` list. | No (`self` not present); tools are intended as stateless functions. | Name, description, and parameter schema auto-extracted from function signature and docstring; supports override args. | Agent SDK exposes tool schemas to LLM; LLM issues function_call (JSON); SDK invokes Python function, returns result. | No built-in namespacing; tool name is unique per agent. | No built-in multi-agent or hierarchy; focus is single-agent tool use (but can be composed in user code). | Tool is a formal object; can override description/schema per agent; allows for dynamic enablement via callable. |
| **LangChain** | Decorate functions with `@tool` or instantiate `Tool`/`StructuredTool`; pass tool objects to agents or chains. | No (`self` not present); tools are stateless. | Name from function or override; description from docstring; input schema via type hints or Pydantic model. | Agent exposes tools to LLM, which may invoke via text (ReAct) or JSON (native function call); framework parses and executes. | Tool name per agent; grouping possible via toolkits. | Multi-agent via chains; complex flows via agent executors or sub-chains; agents can use tools or call sub-agents as tools. | Deep integration with prompt/chain ecosystem; supports both ReAct and structured function calling. |
| **LangGraph** | Uses LangChain's tool registration; no separate tool abstraction; tools registered per agent node. | No (`self` not present); tools are stateless. | Inherits from LangChain’s schema extraction. | Tools are invoked as in LangChain; but flow between agents/tools is defined by explicit graph/state machine. | Tool names per node; workflow-level discovery. | **Explicit multi-agent and stateful workflow orchestration:** nodes are agents or tools, transitions encoded in graph. | Graph-based control flow; agents-as-tools; loops/branches prevented by design. |
| **CrewAI** | Tools/classes (BaseTool) registered via agent/task configuration; can use decorators or configs. | No (`self` not present); tools are stateless. | Name, description from function/class; schema inferred from signature and docstring. | Agent exposes tools to LLM; CrewAI intercepts model’s tool/function call and executes; supports OpenAI JSON and fallback text format. | Tool/task names per agent/task; crew defines available toolbox. | **Tasks orchestrate agents and tools; hierarchical and sequential workflows; router agent pattern for delegation.** | **Explicit multi-agent team abstraction**; per-task toolset overrides; agent can delegate to sub-agents or tools. |
| **Google ADK** | Register plain Python functions (with type hints and docstrings) in agent’s `tools=[...]` list; supports toolsets and built-ins. | No (`self` not present); tools are stateless. | Name from function; schema from signature/type hints; description from docstring; creates OpenAI-style function spec. | LLM agent receives tool schemas; on model function call, ADK executes and returns result; **delegation to sub-agent as alternative to tool call.** | Tool names per agent; agent/team hierarchy can be used for discovery. | **Hierarchical agent teams:** agent can call tools or delegate to sub-agent (agent-as-tool); team structure guides model’s choice. | Deep integration with model provider; agent delegation indistinguishable from tool call for LLM; can turn off tools for JSON agents. |
| **AutoGen** | Tools are classes (subclass `BaseTool`); most common: `FunctionTool(func, description)`; pass to agents or model clients. | No (`self` not present); tools are stateless (but class tools can store state if needed). | Schema auto-generated from type hints; description is argument; exposes `.schema` property for introspection and LLM. | Tools passed to model client; on model function call (JSON), AutoGen parses and executes Python tool; result returned as FunctionExecutionResult. | Tool names per agent/client; no explicit plugin structure, but tools can be grouped in code. | **Supports multi-agent chat, agent-to-agent messages; each agent/tool loop follows function calling pipeline.** | Async execution; per-tool schema inspection; built-in and custom tools; provider-agnostic (OpenAI, local, etc.). |
| **HuggingFace Transformers Agents** | Tools loaded from HF Hub or defined as Python functions/classes; registered via `load_tool` or passed as tool list to agent. | No (`self` not present); tools are stateless. | Name/description from model or function; expected inputs defined per tool; schema varies (loose for code agent, strict for JSON agent). | Model is prompted with available tools; agent parses tool invocation (step-by-step or JSON); executes tool and returns result to model. | Tool names per agent; HF Hub allows large-scale tool discovery. | Supports **ReactAgent** (stepwise tool use) and **ReactJsonAgent** (JSON-based function calling); agents-as-tools for hierarchical composition. | Tight integration with HuggingFace ecosystem; can register pipelines or models as tools; flexible agent-as-tool. |

---

#### Takeaways

- **Semantic Kernel** stands alone in supporting *class-based, stateful plugins* via `self`, enabling sophisticated stateful tool design.
- **All other frameworks** (OpenAI Agent SDK, LangChain, CrewAI, Google ADK, AutoGen, HuggingFace Agents) treat tools as **stateless functions or classes**, registered directly in the agent or agent’s toolset.
- **Schema generation and function calling**: All frameworks generate a schema (usually JSON) from type hints/signature to inform the LLM what tools are available and how to invoke them. The LLM’s response is parsed, the Python function is called, and the result is injected back into the conversation.
- **Multi-agent and orchestration**:  
  - *CrewAI, LangGraph, Google ADK, and AutoGen* support various patterns for multi-agent collaboration, hierarchical delegation, and agent-as-tool composition.
  - *Semantic Kernel* supports plugin isolation by kernel instance, but multi-agent orchestration is handled externally.
- **Unique strengths**:
  - **Semantic Kernel**: Per-plugin state via instance methods.
  - **LangGraph**: Explicit, stateful workflow graphs.
  - **CrewAI/Google ADK**: Agent-as-tool, hierarchical teams, and flexible task routing.
  - **AutoGen**: Provider-agnostic, async, deeply pluggable.
  - **HF Agents**: Out-of-the-box tools from the Hub, code execution as tool.

---
